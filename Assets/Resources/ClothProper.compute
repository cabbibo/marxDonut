

#pragma kernel CSMain
 
#define threadX 6
#define threadY 6
#define threadZ 6

#define strideX 6
#define strideY 6
#define strideZ 6

#define gridX (threadX * strideX)
#define gridY (threadY * strideY)
#define gridZ (threadZ * strideZ)



int _RibbonWidth;
int _RibbonLength;
//int _NumberHands;
int _Iteration;
int _Offset;
int _Total;
int _WhichOne;
float _DeltaTime;


/*

	Possible bugs
	-otherVertIds array can't be used in struct?
	-can't write to multiple locations?


*/

struct Vert{
	float3 pos;
	float3 oPos;
	float3 ogPos;
	float mass;
	float ids[8];
	float3 debug;
};

struct Pos{
	float3 pos;
};

struct Hand{
  float3 pos;
  float  triggerVal;
};

struct Shape{
	float4x4 mat;
};


RWStructuredBuffer<Vert> vertBuffer;
RWStructuredBuffer<Pos> ogBuffer;
RWStructuredBuffer<float4x4> transBuffer;
RWStructuredBuffer<Hand> handBuffer;


int getID( Vert v , int id ){

	/*if( id == 0 ){ return v.o0; }else
	if( id == 1 ){ return v.o1; }else
	if( id == 2 ){ return v.o2; }else
	if( id == 3 ){ return v.o3; }else
	if( id == 4 ){ return v.o4; }else
	if( id == 5 ){ return v.o5; }else
	if( id == 6 ){ return v.o6; }else
				 { return v.o7; }
*/

return v.ids[id];

}

float3 getVel( float3 p1 , float3 p2 ){

	float3 v = p1 - p2;

	if( length( v )> 3.1 / (float( _WhichOne + 1 ))){ v = normalize( v ) * 3.1 / (float( _WhichOne + 1 )); }
	return v;
}

float3 setPos( Vert v , float3 p ){

	return p;
	if( v.ids[0] > -1 && v.ids[2] > -1 && v.ids[4] > -1 && v.ids[6] > -1){
		return p;
	}else{
		return v.pos;
	}



}


[numthreads(threadX,threadY,threadZ)]
void CSMain (uint3 id : SV_DispatchThreadID) {
  
  	int pID = id.x + id.y * gridX + id.z * gridX * gridY;

  	Vert vert = vertBuffer[ pID ];
	vert.mass = .4;

  	int row = int(floor( float(pID) / float(_RibbonWidth)));
  	int col = int(pID) % int(_RibbonWidth);


  	//choosing which lil critters we are dealing with
  	//this round!
  	bool o1 = _Iteration == 1 && (row % 3) == 0 && (col % 3) == 0;
  	bool o2 = _Iteration == 2 && (row % 3) == 1 && (col % 3) == 0;
  	bool o3 = _Iteration == 3 && (row % 3) == 2 && (col % 3) == 0;
  	bool o4 = _Iteration == 4 && (row % 3) == 0 && (col % 3) == 1;
  	bool o5 = _Iteration == 5 && (row % 3) == 1 && (col % 3) == 1;
  	bool o6 = _Iteration == 6 && (row % 3) == 2 && (col % 3) == 1;
  	bool o7 = _Iteration == 7 && (row % 3) == 0 && (col % 3) == 2;
  	bool o8 = _Iteration == 8 && (row % 3) == 1 && (col % 3) == 2;
  	bool o9 = _Iteration == 9 && (row % 3) == 2 && (col % 3) == 2;



  	// don't need to compute this every time;
  	float clothSize = 1;
  	float2 xy = float2( clothSize / float(_RibbonWidth) ,  clothSize / float(_RibbonWidth) );
  	float3 clothDistances =  float3( xy.x , xy.y , length( xy ) );
  	clothDistances *= 1.;
 


	// GRAVITY
	float3 force = float3( 0 , -.3 , 0 );
	float mass = 1;
	float3 acceleration= 0; 

	vert.mass = 1;

	// In iteration 0, solve for external forces
	if( _Iteration ==  0  ){

		//if(_WhichOne == 0 ){
		
			acceleration = force / float3( vert.mass , vert.mass , vert.mass );


			vert.pos += acceleration * _DeltaTime * _DeltaTime / (float( _WhichOne + 1 )/1);

			if( vert.pos.y < 0 ){
				vert.pos.y = 0;
			}

		//}

		float3 testSphere = float3( 0.0 , .2, 0.3);

		if( length(vert.pos - testSphere) < .1 ){
/*
			float3 ro = vert.pos;
			float3 rd = normalize(float3( 0 , -.2 , 0 ));
			float t = 0;
			for( int i = 0; i < 6; i++ ){
				float m = length( ro - testSphere )-.1;
				if( m > 0 ){ break; }
				ro += rd * m;
			}
			vert.pos = ro;*/

			vert.pos = normalize(vert.pos - testSphere) *.1 + testSphere;

		}




	//do inertia
	}else if( _Iteration == 10  ){


		if(_WhichOne == 0 ){

			// Inertia: objects in motion stay in motion.
			float3 vel = getVel( vert.pos , vert.oPos);

			float3 next = vert.pos + vel * .3 / (float( _WhichOne + 1 )/1);

			vert.oPos = vert.pos;
			vert.pos = next;

		}



    // solve for cloth constraints
	}

 	//o1 = true;

 	// flips the verts that we are solving force
 	// depending on which iteration of the computer shader
 	// we are working with;
  	if( o1 || o2 || o3 || o4 || o5 || o6 || o7 || o8 || o9 ){


		// 5 6 7 
		// 4 o 0
	    // 3 2 1
		//int iterationID = _Iteration - 1;

		for( int j = 0; j < 4; j++){
		for( int i = 0; i < 8; i++ ){

			int vertID = getID( vert , i ); //int(vert.otherVertIds[iterationID]);

			// Dont solve if there is no connection
			if( vertID >= 0){
	        
				Vert vert2 = vertBuffer[ vertID ];


				float clothDistance = clothDistances.x;

				//Setting to diagonal
				if(i % 2 == 1){ clothDistance = clothDistances.z; }

				//Setting to vertical
				if(i ==2 || i == 6){ clothDistance = clothDistances.y; }

				float3 dif = vert.pos - vert2.pos;

				float l = length( dif );

				float difference = ((clothDistance) - l ) / l;

				float3 translate = dif * .5 * difference / ( j + 1);// /  float( _WhichOne + 1);


				float3 t1 = 1 * translate; // vert.mass;
				float3 t2 = 1 * translate; // vert2.mass;
				
				float3 n1 = vert.pos + t1;
				float3 n2 = vert2.pos - t2;

				vert.pos = setPos( vert , n1 );
				vert2.pos = setPos( vert2 , n2 );

				vertBuffer[ vertID ] = vert2;

			}
		
		}
		}

		


	}


	
	if( vert.ids[0] < 0 ){
		//vert.oPos = vert.ogPos;
		//vert.pos = vert.ogPos;
	}



	

	vertBuffer[pID] = vert;



	//vert.pos = float3( 0 , 1 , 0 );


	
}
